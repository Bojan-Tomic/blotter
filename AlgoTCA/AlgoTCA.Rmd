---
title: AlgoTCA - GSoC 2019
author:
  - name: Vito Lestingi
    affiliation: Student - University of Rome
    address:
    - line 1
    - line 2
    email:  author1@work
  - name: Jasen K Mackie
    affiliation: Algorithmic Trading Services - Iress
    address:
    - line 1
    - line 2
    email:  jasen.mackie@iress.com
  - name: Brian G Peterson
    affiliation: TODO
    address:
    - line 1
    - line 2
    email:  brian@braverock.com
abstract: >
  As part of the R organization’s participation in the Google Summer of Code 2019 we replicate, and to some degree extend, the pre and post-trade TCA models as disclosed in “The Science of Algorithmic Trading and Portfolio Management” – Robert L. Kissell. The main focus of this 3-month programme was to build an Implementation Shortfall TCA model and a range of benchmark price performance models (VWAP, PWP, RPM, Arrival Cost etc), models for statistically comparing different algorithmic execution performances and lastly replicating Kissell’s I* model for Market Impact estimates. Using 11 months of JSE data and 16200 observations we are able to train a non-linear least squares estimation function which converges on a plausible solution, allowing us to validate the model which can be used in production for larger datasets with presumably lower variance.
output:
  rticles::rjournal_article:
    includes:
      in_header: preamble.tex
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{AlgoTCA.Rmd}
  %\usepackage[UTF-8]{inputenc}
  %\VignetteEncoding{UTF-8}
---

## Introduction

Post-trade Transaction Cost Analysis (TCA) is critical for assessing the efficiency with which trading decisions are implemented, especially for the institutional investor whose trade ideas can span multiple time periods to implement and which risks adverse market impact if not managed accordingly. Pre-trade and intra-day TCA is an equally vital component for making optimal trading decisions based on market conditions and trading constraints. The [blotter](https://github.com/braverock/blotter) package in R is an ideal package in the R ecosystem for hosting TCA functionality since it serves as the transaction infrastructure for building and analysing simulated and production trading systems. In this article we describe the functions implemented as part of this GSoC 2019 project in 3 parts, namely: 1. Post-trade TCA models, 2. Models for the statistical comparison of algorithmic executions, 3. Pre-trade Market Impact estimation using the I* model as documented in “The Science of Algorithmic Trading and Portfolio Management” – Robert L. Kissell, originally developed by Kissell and Malamut in 1998. Where appropriate we include examples, elaborate on extensions, document the journey of a supposed analyst and communicate results and findings relevant to a user. Lastly we comment on interesting paths of future work.

## 1. Post Trade TCA

## Implementation Shortfall 

Implementation Shortfall is a measure that represents the total cost of executing an investment idea. Implementation Shortfall is calculated as the difference between the paper return of a portfolio where all shares are assumed to have transacted at the manager's decision price and the actual return of the portfolio using actual transaction prices and shares executed.


Implementation Shortfall can be implemented in 4 ways:

1. Assuming Complete Execution, implying a zero opportunity cost component. This is the default method for \code{Implementation Shortfall}

The simplest formulation for the Complete Execution IS method is:

$$ IS = S . P_{avg} - S . P_{d} + fees $$

Note that we add fees, as a positive metric indicates a cost.

2. Using an Opportunity Cost (Perold 1988) component, where not all shares originally allocated for trading are finally executed. Opportunity Cost is the cost of not executing a portion of the originally allocated shares \code{S} for execution. This could be due to limit price constraints or a lack of liquidity.

The formulation for Opportunity Cost is:

$$ {(S - \sum s_{j}) . (P_{n} - P_{d})} $$

The Implementation Shortfall formulation of Perold (1988) can be written as:

$$ {IS = \sum s_{j} . (P_{avg} - P_{d}) + (S - \sum s_{j}) . (P_{n} - P_{d}) + fees} $$

3. Expanded Implementation Shortfall (Wayne Wagner)

Wayne Wagner's implementation categorizes costs into delay, trading and opportunity related costs. Assuming $ P_{d} $ is the decision price, $ P_{0} $ is the price when trading begins (ideally Arrival Price, defined as the mid-price at order arrival, alternatively Last Price at order arrival or failing that data availability then first transaction price), and $ P_{n} $ is the price at the end of
trading. The Expanded IS can be written as:

$$ (P_{n} - P_{d}) = (P_{n} - P_{0}) + (P_{0} - P_{d}) $$

If you substitute the RHS into Perold's IS, then IS can be written as:

$$ IS = (\sum s_{j}p_{j} - \sum s_{j}P_{d}) + (S - \sum s_{j}) . ((P_{n} - P_{0}) + (P_{0} - P_{d})) + fees $$

This formula can be re-written into a separate delay, trading and opportunity cost related component as follows:

$$ Expanded IS = S(P_{0} - P_{d}) + (\sum s_{j})(P_{avg} - P_{0}) + (S - \sum s_{j})(P_{n} - P_{0}) + fees $$

where each term (excluding fees) reflects the delay, trading and opportunity cost components respectively. Wagner's method allows for an additional decomposition of the "Delay related cost" into the \emph{opportunity delay cost} component and the \emph{trading delay cost} component. Our implementation provides this breakdown in the output.

4. Market Activity IS, which assumes the analyst is unaware of the manager's decision price. This method is equivalent to the Wagner formulation except that the first term is excluded in order to assess only market activity IS:

$$ Market Activity IS = (\sum s_{j})(P_{avg} - P_{0}) + (S - \sum s_{j})(P_{n} - P_{0}) + fees $$


## Implementation Shortfall - Examples

For the IS examples we borrow from the code in the function help documentation. The first 2 examples below illustrate the output for the Complete Execution and Market Activity implementations using identical datasets. The Implementation Shortfall quantums are identical as we assume complete execution in both instances including the Market Activity IS, although you will notice this version returns additional info when compared with the Complete Execution version, including filled and unfilled units, the opportunity cost component and fees.
```{r, include=FALSE}
# set up test_txns assuming all 5k shares traded
require(xts)
require(FinancialInstrument)
require(blotter)
require(quantmod)
test_txns <- xts(cbind(rep(10:11,5),rep(500,10),TxnFees = rep(-10,10)), 
                 seq.POSIXt(as.POSIXct("2000-01-01 09:00:00"),
                 as.POSIXct("2000-01-01 18:00:00"),
                 by = "hours"))
colnames(test_txns) <- c("TxnPrice","TxnQty","TxnFees")

stock.str='test_txns' # what are we trying it on
currency('USD')
stock(stock.str,currency='USD',multiplier=1)
suppressWarnings(rm("account.testport","portfolio.testport",pos=.blotter))
initPortf("testport", symbols=stock.str)
initAcct("testport","testport", symbols=stock.str)
addtxns <- addTxns("testport","test_txns",test_txns)
updatePortf("testport")
p = getPortfolio("testport") # make a local copy of the portfolio object
a = getAccount("testport") # make a local copy of the account object
p$symbols$test_txns$txn
```


```{r}
### Complete Execution IS
impShortfall("testport", "test_txns",
          paQty=5000,
          priceStart=10,
          priceEnd=11,
          arrPrice=10,
          method='Complete')
```

```{r}
### Market Activity IS
impShortfall("testport", "test_txns",
          paQty=5000, 
          priceEnd=11,
          arrPrice = 10,
          method='Market')
```


The next 2 examples illustrate the Perold and Wagner versions, respectively, again using identical datasets in both cases. We assume only 4,000 of the originially allocated 5,000 units eventually trade.
```{r, include=FALSE}
# set up test_txns assuming assuming only 4k shares traded
test_txns <- test_txns[-c(2:3),]
suppressWarnings(rm("account.testport","portfolio.testport",pos=.blotter))
initPortf("testport", symbols=stock.str)
initAcct("testport","testport", symbols=stock.str)
addtxns <- addTxns("testport","test_txns",test_txns)
updatePortf("testport")
p = getPortfolio("testport") # make a local copy of the portfolio object
a = getAccount("testport") # make a local copy of the account object
p$symbols$test_txns$txn
```

For the Perold output, we see the breakdown between Execution Cost, Opportunity Cost and Fees separately.
```{r}
### Perold
impShortfall("testport", "test_txns",
          paQty=5000,
          priceStart=10,
          priceEnd=11,
          arrPrice=10,
          method='Perold')
```

In the case of the Wagner implementation, we see the extra breakdown compared with Perold, ultimately equating to the same hypothetical Implementation Shortfall measure.
```{r}
### Wagner
impShortfall("testport", "test_txns",
          paQty=5000,
          priceStart=10,
          priceEnd=11,
          arrPrice=10.25,
          method='Wagner')

```

## Benchmark Price Performance - Examples

We built a single function for computing TCA benchmarks where the benchmark price is one of: Arrival Price, Day's Open/Close/Other, Participation Weighted Price (PWP), Volume Weighted Average Price (VWAP) or a qualitative score with the Realtive Performance Measure (RPM). When all methods are used in conjunction, an analyst can derive measures for each benchmark giving a different view of the resultant execution. In addition to giving an overall score, we have built an S3 method for plotting the performance through the life of the execution which allows an analyst to identify specific time periods that warrant additional review.

### benchmark='TradeBench'

For all 4 methods we use the same sampled set of public trades data to simulate a private execution. In all cases, a positive value indicates outperformance and a negative value, underperformance. In the case of \code{benchmark='TradeBench'} the benchmark price is the first transaction price in the execution, as a proxy for the Arrival Price. For a true Arrival Cost benchmark using the actual Arrival Price, the user can use \code{benchmark='MktBench'} with the Arrival Price specified for with the 'priceToBench' argument.

```{r, include=FALSE}
set.seed(333)
.blotter <- new.env()
data(ABC)
ABC.day <- ABC[which(as.Date(index(ABC)) == "2019-02-01"), ]
colnames(ABC.day) <- c('MktPrice', 'MktQty')
inds <- sample(nrow(ABC.day), 50)
abc.trades.day <- ABC.day[inds]
colnames(abc.trades.day) <- c('TxnPrice', 'TxnQty')
currency('USD')
stock('ABC', currency = 'USD', multiplier = 1, tick_size = 0.01)
initPortf('abc.port.day', symbols = 'ABC')
addTxns('abc.port.day', 'ABC', TxnData = abc.trades.day)
updatePortf('abc.port.day', 'ABC')
```

```{r}
benchTradeBench <- benchTradePerf('abc.port.day', 'ABC', side = 1, benchmark = 'TradeBench', MktData = ABC.day)
last(benchTradeBench$Trades.TradeBench.Perf)

plot(benchTradeBench, benchmark = 'TradeBench')
```

### benchmark='MktBench'

As alluded to previously, with \code{benchmark='MktBench'} the user can specify "Open", "Close" or a numeric price value for benchmarking.

```{r}
benchMktBenchOpen <- benchTradePerf('abc.port.day', 'ABC', side = 1, benchmark = 'MktBench', type = list(price = 'Open'), MktData = ABC.day[1]) # performance against daily open price
last(benchMktBenchOpen$Trades.MktBench.Perf)

plot(benchMktBenchOpen, benchmark = 'MktBench')
```

```{r}
benchMktBenchClose <- benchTradePerf('abc.port.day', 'ABC', side = 1, benchmark = 'MktBench', type = list(price = 'Close'), MktData = ABC.day[nrow(ABC.day)]) # performance against daily closing price
last(benchMktBenchClose$Trades.MktBench.Perf)

plot(benchMktBenchClose, benchmark = 'MktBench')
```

### benchmark='VWAP'

A widely used benchmark is the Volume Weighted Average Price (VWAP) benchmark. The benchmark is defined as:

$$ VWAP = \frac{\sum {P_{j}Q_{j}}}{\sum {Q_{j}}} $$

P_{j} is the market price and Q_{j} the market volume, during j trading periods activity of the market. Two different types of VWAP benchmarks are included in the present function, the Interval VWAP and the Full VWAP. Referring to the former as the VWAP where the j market trading periods considered are the ones during which the order is being executed, whereas the latter includes all the j market periods from order execution beginning to last transaction. The VWAP benchmark varies by timespan considered and is commonly used as a proxy for fair market price. It can differ by data vendors specific market data filtering. There are recognized drawbacks of this benchamrk. First of all, the larger the order the closer the execution will be to VWAP. Second, where large block trades occur these could skew the benchmark. Lastly, it is not an indicated comparison across stocks or different days for the same stock.

```{r}
benchVWAPinterv <- benchTradePerf('abc.port.day', 'ABC', side = 1, benchmark = 'VWAP', type = list(vwap = 'interval'), MktData = ABC.day)
last(benchVWAPinterv$Trades.VWAP.Perf)

plot(benchVWAPinterv, benchmark = 'MktBench')
```

### benchmark='PWP'

A variation of the VWAP benchmark is given by the Participation Weighted Price (PWP) benchmark, where the weighting is with respect to the PWP shares:

$$ PWP shares = \frac{Traded shares}{POV} $$

POV refers to the percentage of volume. 

The PWP benchwark is:

$$ PWP price = \frac{\sum {P_{h}Q_{h}}}{\sum {Q_{h}}} $$

where h are the periods from the arrival time of the order into the market until when the PWP shares are completely executed. As the VWAP, the PWP benchmark provides a glimpse into market fair prices. However this benchmark have limitations similar to the VWAP. It is subject to manipulation in that the market price can be kept inflated by larger orders. Furthermore, as the VWAP, it is not comparable between stocks or across days for the same stock. Also, the benchmark may be biased by temporary impact dissipation.

```{r}
benchPWP <- benchTradePerf('abc.port.day', 'ABC', side = 1, benchmark = 'PWP', POV = 0.3, MktData = ABC.day)
last(benchPWP$Trades.PWP.Perf)

plot(benchPWP, benchmark = 'PWP')
```

###  benchmark='RPM'

Lastly, the Relative Performance Measure (RPM), which differs from the PnL metrics above, is a percentile ranking of trading activity. Its expression depends on the side of the trade:

$$ RPM_{buy} = 0.5 * \frac{Total volume + Volume at P > P_{avg} - Volume at P < P_{avg}}{Total volume} $$

$$ RPM_{sell} = 0.5 * \frac{Total volume + Volume at P < P_{avg} - Volume at P > P_{avg}}{Total volume} $$

where P is the market price specified. The an RPM over 50% is considered as an indication of superior trades, more precisely the RPM can be mapped to a qualitative score of the trades:

0 <= RPM < 20	Fair
20 <= RPM < 40	Poor
40 <= RPM <= 60	Average
60 < RPM <= 80	Good
80 < RPM <= 100	Excellent

This measure is considered as preferred to the VWAP metric because it overcomes some of its drawbacks: it can be used to compare performance across different stocks, days, and volatility; it is not less influenced by large blocks trade at extreme prices.

```{r}
benchRPM <- benchTradePerf('abc.port.day', 'ABC', side = 1, benchmark = 'RPM', MktData = ABC.day)
last(benchRPM$Trades.RPM.Perf)

plot(benchRPM, benchmark = 'RPM')
```

This section may contain a figure such as Figure \ref{figure:rlogo}.

\begin{figure}[htbp]
  \centering
  \includegraphics{Rlogo}
  \caption{The logo of R.}
  \label{figure:rlogo}
\end{figure}

## Another section

There will likely be several sections, perhaps including code snippets, such as:

```{r}
x <- 1:10
x
```

## Summary

This file is only a basic article template. For full details of _The R Journal_ style and information on how to prepare your article for submission, see the [Instructions for Authors](https://journal.r-project.org/share/author-guide.pdf).
\bibliography{RJreferences}
